pragma solidity ^0.4.20;

///using oraclize to generate random number
import "github.com/oraclize/ethereum-api/oraclizeAPI.sol";


contract AresLottery is usingOraclize {
    
    event newRandomNum_uint(uint randomNumber);
    event LogProofOraclizeQuery(string description);

    // need to set how many winners we want to choose
    uint8 public maximumWinners = 1;
    // store win numbers
    uint32 public winNumbers;
    
    uint32 public maxTktNum;
    
    uint public gasForOraclize;
    uint public contractBalance;
    
    mapping(bytes32=>bool) validIds;

    // CEO is the owner of this contract and only CEO can execute lottery function 
    address public CEOAddress;

    // checks only CEO address is calling
    modifier onlyCEO() {
        require(msg.sender == CEOAddress);
        _;
    }
    
 /// init function, get CEOAddress which is the one who deployed the contract 
    
    function AresLottery() public payable {
        CEOAddress = msg.sender;

        oraclize_setNetwork(networkID_auto);
        // use Ledger for oraclize call 
        oraclize_setProof(proofType_Ledger);

        /* give enough balance here, each random number generated by Oraclize costs 0.008 ether
        *   and extra gas is needed
        */
        contractBalance = msg.value;
    } 

/// getting tickets range 
    function joinLottery(uint32 maxTicketNum) public {
        require(maxTicketNum >= 0 && maxTicketNum < 4294967295);
        maxTktNum = maxTicketNum; 
    }

/// start lotter, only CEO can execute it 
    function startLottery() public payable onlyCEO {
        // number of random bytes we want the datasource to return, maximum bytes (2^(8*4))
        uint N = 4; 
        // number of seconds to wait before the execution takes place
        uint delay = 0; 
        // gas for callback function
        gasForOraclize = 300000; 

        // this function internally generates the correct oraclize_query and returns its queryId
        bytes32 queryId = oraclize_newRandomDSQuery(delay, N, gasForOraclize); 
    }
 
/// the callback function is called by Oraclize when the result is ready
/// the oraclize_randomDS_proofVerify modifier prevents an invalid proof to execute this function code:
/// the proof validity is fully verified on-chain
    function __callback(bytes32 _queryId, string _result, bytes _proof) public oraclize_randomDS_proofVerify(_queryId, _result, _proof) { 
        require(msg.sender == oraclize_cbAddress());

        uint32 maxRange = maxTktNum; // this is the highest uint we want to get. It should never be greater than 2^(8*N), where N is the number of random bytes we had asked the datasource to return
        // get randomNumber in the [0+1, maxRange] range
        uint32 randomNumber = uint32(keccak256(_result)) % maxRange + 1; 
        winNumbers = randomNumber;
        // add log event 
        newRandomNum_uint(randomNumber);// this is the resulting random number (uint)
    }

/// define how manu winners we want to choose if we want to change
    function setMaxWinners(uint8 maxWinners) public onlyCEO {
        maximumWinners = maxWinners;    
    }
    
    function getWinners() public view returns(uint32) {
        return winNumbers;
    }
    
///only CEO can adjust contract balance 
    function updateContractBalance() public payable onlyCEO {
        contractBalance += msg.value;
    }
    
/// only CEO can withdraw balance 
    function withdraw() external onlyCEO {
        CEOAddress.transfer(this.balance);
    }
    
/// transfer balance back to CEO then destroy the contract
    function destroy() onlyCEO public {
        selfdestruct(CEOAddress);
    }
}
