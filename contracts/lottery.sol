pragma solidity ^0.4.20;

// using oraclize to generate random number
import "github.com/oraclize/ethereum-api/oraclizeAPI.sol";

contract AresLottery is usingOraclize {

  event newRandomNum_uint(uint randomNumber);
  event LogProofOraclizeQuery(string description);

  // number of winners we want to choose
  uint8 public numWinners;
  // storing win numbers
  uint32[] public winNumbers;

  uint32 public minTktNum;
  uint32 public maxTktNum;

  uint public gasForOraclize;
  uint public contractBalance;

  mapping(bytes32=>bool) validIds;

  // CEO is the owner of this contract and only CEO can execute lottery function
  address public CEOAddress;

  /*
   * checks only CEO address is calling
   */
  modifier onlyCEO() {
    require(msg.sender == CEOAddress);
    _;
  }

  /*
   * init function, get CEOAddress which is the one who deployed the contract
   */
  function AresLottery() public payable {
    CEOAddress = msg.sender;

    oraclize_setNetwork(networkID_auto);
    /* use Ledger for oraclize call */
    oraclize_setProof(proofType_Ledger);

    /* give enough balance here, each random number generated by Oraclize costs 0.008 ether
     * and extra gas is needed
     */
    contractBalance = msg.value;
  }

  // getting tickets range
  function joinLottery(uint32 minTicketNum, uint32 maxTicketNum) public {
    require(minTicketNum >= 0 && maxTicketNum >= 0);
    require(minTicketNum < 4294967295 && numWinners < 4294967295);

    minTktNum = minTicketNum;
    maxTktNum = maxTicketNum;
  }

  // start lotter, only CEO can execute it
  function startLottery() public payable onlyCEO {
    // number of random bytes we want the datasource to return, maximum bytes (2^(8*4))
    uint N = 4;
    // number of seconds to wait before the execution takes place
    uint delay = 0;
    // gas for callback function
    gasForOraclize = 300000;

    // generates the correct oraclize_query internally and returns its queryId
    for (uint i = 0; i < numWinners; i++) {
      bytes32 queryId = oraclize_newRandomDSQuery(delay, N, gasForOraclize);
      validIds[queryId] = true;
    }
  }

  // callback function is called by Oraclize when the result is ready
  // oraclize_randomDS_proofVerify modifier prevents an invalid proof to execute this function code:
  // the proof validity is fully verified on-chain
  function __callback(bytes32 _queryId, string _result, bytes _proof) public oraclize_randomDS_proofVerify(_queryId, _result, _proof) {
    require(msg.sender == oraclize_cbAddress());
    require(winNumbers.length <= numWinners);
    require(validIds[_queryId]);

    uint32 maxRange = (maxTktNum - minTktNum + 1); // this is the highest uint we want to get. It should never be greater than 2^(8*N), where N is the number of random bytes we had asked the datasource to return
    // get randomNumber in the [0, maxRange] range
    uint32 randomNumber = uint32(keccak256(_result)) % maxRange;
    winNumbers.push(randomNumber);

    newRandomNum_uint(randomNumber);// this is the resulting random number (uint)
    validIds[_queryId] = false;
  }

  // define how manu winners we want to choose
  function setMaxWinners(uint8 maxWinners) public onlyCEO {
    numWinners = maxWinners;
  }

  function getWinners() public view returns(uint32[]) {
    return winNumbers;
  }

  // clean all the info before start another round
  function cleanUp() public onlyCEO {
    // delete winNumbers array
    delete winNumbers;
  }

  // only CEO can adjust contract balance
  function updateContractBalance() public payable onlyCEO {
    contractBalance += msg.value;
  }

  // only CEO can withdraw balance
  function withdraw() external onlyCEO {
    CEOAddress.transfer(this.balance);
  }

  // transfer balance back to CEO then destroy the contract
  function destroy() onlyCEO public {
    selfdestruct(CEOAddress);
  }
}
